1;Чтобы алгоритм бинарного поиска работал правильно, нужно, чтобы массив (список) был:;Отсортированным;Несортированным;В куче;Выходящим из стека
2;Определите максимальное количество узлов в двоичном дереве с высотой k, где корень — нулевая высота (0).;2ᵏ − 1;2ᵏ⁺¹ – 1;2ᵏ⁻¹ + 1;2ᵏ + 1
2;Что означает следующая фраза: «алгоритм X асимптотически более эффективен, чем Y»?;X будет лучшим выбором для всех входов;X будет лучшим выбором для всех входов, за исключением, возможно, небольших входов;X будет лучшим выбором для всех входов, кроме больших входов;Y будет лучшим выбором для небольших входов
2;Алгоритм обхода графа отличается от алгоритма обхода вершин дерева тем, что…;Деревья не соединяются;Графы могут иметь циклы;У деревьев есть корни;Все утверждения выше ошибочны: дерево — подмножество графа
2;Какой алгоритм из нижеперечисленных будет самым производительным, если дан уже отсортированный массив?;Сортировка слиянием;Сортировка вставками;Быстрая сортировка;Пирамидальная сортировка
4;Что делает следующая функция на языке C? \u000A int Trial (int a, int b, int c) {\u000A if ((a >= b) && (c < b)) \u000A  return b\u003B \u000A else if (a>=b) \u000A  return Trial(a, c, b)\u003B \u000A else \u000A return Trial(b, a, c)\u003B \u000A};Находит максимальное значение a, b и c;Находит минимальное значение a, b и c;Находит среднее число a, b и c;Ничего из вышеперечисленного
3;Алгоритм Дейкстры основан на:;Парадигме «разделяй и властвуй»;Динамическом программировании;Жадном подходе (Greedy Approach);Поиске с возвратом
5;Какой алгоритм не основан на жадном подходе?;Алгоритм нахождения кратчайшего пути Дейкстры;Алгоритм Прима;Алгоритм Крускала;Алгоритм Хаффмана;Алгоритм нахождения кратчайшего пути Беллмана-Форда
3;Что выполняет следующее выражение на C? x = x & (x-1);Устанавливает все биты в виде 1;Делает x равным 0;Отключает самый правый бит из установленных;Отключает самый левый бит
4;Рассмотрите программу ниже и определите её сложность. \u000A void function(int n) { \u000A int i, j, count=0\u003B \u000A for (i=n/2\u003B i <= n\u003B i++) \u000A for (j = 1\u003B j <= n\u003B  j = j*2) \u000A count++\u003B \u000A};O(log n);O(n²);O(n² log n);O(n log n)